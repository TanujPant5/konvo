rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================
    // KONVO - ANONYMOUS CHAT PLATFORM SECURITY RULES
    // Version: 2.1 (Synchronized with app.js v2.0)
    // ============================================================
    // Changes from v2.0:
    // - Fixed admin ban functionality (set with merge support)
    // - Added isPinned field validation for admin updates
    // - Fixed pinned message text limit (200 chars per app.js)
    // - Added 'anonymous' to reserved usernames
    // - Improved admin update validations
    // - Fixed typing status timestamp validation
    // ============================================================

    // ============================
    // 1. HELPER FUNCTIONS
    // ============================

    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isBanned() {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/banned_users/$(request.auth.uid));
    }

    function isActiveUser() {
      return isSignedIn() && !isBanned();
    }

    function isAdmin() {
      return isSignedIn() &&
             !isBanned() &&
             exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // ============================
    // 2. VALIDATION FUNCTIONS
    // ============================

    // Validate message text content
    function isValidText() {
      let text = request.resource.data.text;
      return text is string
             && text.size() > 0
             && text.size() <= 2000
             && !text.matches('.*[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F].*');
    }

    // Force server timestamp
    function isServerTimestamp() {
      return request.resource.data.timestamp == request.time;
    }

    // Whitelist valid message collections
    function isValidCollection(col) {
      return col in ['chat', 'confessions'];
    }

    // Rate limiting: 1 message per 2 seconds
    function canSendMessage() {
      let userDoc = /databases/$(database)/documents/users/$(request.auth.uid);
      return isActiveUser() && (
        !exists(userDoc) ||
        !('lastMessageAt' in get(userDoc).data) ||
        get(userDoc).data.lastMessageAt + duration.value(2, 's') < request.time
      );
    }

    // Validate username format (matches app.js isValidUsername)
    function isValidUsername(username) {
      return username is string
             && username.size() >= 1
             && username.size() <= 30
             && username.matches('^[a-zA-Z0-9_\\- ]+$')
             // Reserved usernames (synced with app.js)
             && username.lower() != 'anonymous'
             && username.lower() != 'admin'
             && username.lower() != 'moderator'
             && username.lower() != 'system'
             && username.lower() != 'konvo'
             && username.lower() != 'mod'
             && !username.lower().matches('.*anonymous.*')
             && !username.lower().matches('.*admin.*')
             && !username.lower().matches('.*moderator.*')
             && !username.lower().matches('.*konvo.*')
             && !username.lower().matches('.*mod.*');
    }

    // Validate profile photo URL (matches app.js isValidProfilePhotoURL)
    function isValidProfilePhotoURL(url) {
      return url is string
             && url.size() <= 500
             && (
               url.matches('^https://placehold\\.co/.*')
               || url.matches('^https://ui-avatars\\.com/.*')
               || url.matches('^https://api\\.dicebear\\.com/.*')
             );
    }

    // Validate user profile creation (by user)
    function isValidUserProfileCreate() {
      let data = request.resource.data;
      let allowedFields = ['username', 'profilePhotoURL', 'lastMessageAt'];
      
      return data.keys().hasOnly(allowedFields)
             && (!('username' in data) || isValidUsername(data.username))
             && (!('profilePhotoURL' in data) || isValidProfilePhotoURL(data.profilePhotoURL))
             && (!('lastMessageAt' in data) || data.lastMessageAt == request.time);
    }

    // Validate user profile update (by user)
    function isValidUserProfileUpdate() {
      let data = request.resource.data;
      let changedFields = data.diff(resource.data).affectedKeys();
      let allowedFields = ['username', 'profilePhotoURL', 'lastMessageAt'];
      
      return changedFields.hasOnly(allowedFields)
             && (!('username' in data) || isValidUsername(data.username))
             && (!('profilePhotoURL' in data) || isValidProfilePhotoURL(data.profilePhotoURL))
             && (!('lastMessageAt' in data) || data.lastMessageAt == request.time)
             // CRITICAL: Users cannot modify banned field
             && !('banned' in changedFields);
    }

    // Validate admin creating user doc (for banning users without profile)
    function isValidAdminUserCreate() {
      let data = request.resource.data;
      return data.keys().hasOnly(['banned'])
             && data.banned is bool;
    }

    // Validate admin updating user (for ban/unban)
    function isValidAdminUserUpdate() {
      let data = request.resource.data;
      let changedFields = data.diff(resource.data).affectedKeys();
      
      // Admin can only modify banned field via this rule
      return changedFields.hasOnly(['banned'])
             && data.banned is bool;
    }

    // Validate typing status (matches app.js updateTypingStatus)
    function isValidTypingStatus() {
      let data = request.resource.data;
      let allowedFields = ['isTyping', 'timestamp'];
      
      return data.keys().hasOnly(allowedFields)
             && data.isTyping is bool
             && data.timestamp is int
             && data.timestamp > 0
             // Allow some clock skew (5 seconds)
             && data.timestamp <= request.time.toMillis() + 5000;
    }

    // Validate new message creation
    function isValidMessageCreate() {
      let data = request.resource.data;
      let allowedFields = ['text', 'timestamp', 'userId', 'replyTo'];
      
      return data.keys().hasOnly(allowedFields)
             && data.userId == request.auth.uid
             && isValidText()
             && isServerTimestamp()
             && (!('replyTo' in data) || isValidReplyTo(data.replyTo));
    }

    // Validate replyTo structure (matches app.js postMessage)
    function isValidReplyTo(replyTo) {
      return replyTo is map
             && replyTo.keys().hasOnly(['messageId', 'userId', 'text'])
             && replyTo.messageId is string
             && replyTo.messageId.size() > 0
             && replyTo.messageId.size() <= 100
             && replyTo.userId is string
             && replyTo.userId.size() > 0
             && replyTo.userId.size() <= 128
             && replyTo.text is string
             && replyTo.text.size() <= 500;
    }

    // Validate hiddenFor update (user can only add themselves)
    function isValidHiddenForUpdate() {
      let oldHiddenFor = resource.data.get('hiddenFor', []);
      let newHiddenFor = request.resource.data.get('hiddenFor', []);
      
      return newHiddenFor is list
             && newHiddenFor.size() <= 1000
             // Must contain all old entries
             && newHiddenFor.hasAll(oldHiddenFor)
             // Can only add one entry (themselves)
             && newHiddenFor.size() == oldHiddenFor.size() + 1
             && request.auth.uid in newHiddenFor
             && !(request.auth.uid in oldHiddenFor);
    }

    // Validate reactions structure (matches app.js REACTION_TYPES)
    function isValidReactionsUpdate() {
      let reactions = request.resource.data.reactions;
      let validTypes = ['thumbsup', 'laugh', 'surprised', 'heart', 'skull'];
      
      return reactions is map
             && reactions.keys().hasOnly(validTypes)
             && (!('thumbsup' in reactions) || (reactions.thumbsup is list && reactions.thumbsup.size() <= 500))
             && (!('laugh' in reactions) || (reactions.laugh is list && reactions.laugh.size() <= 500))
             && (!('surprised' in reactions) || (reactions.surprised is list && reactions.surprised.size() <= 500))
             && (!('heart' in reactions) || (reactions.heart is list && reactions.heart.size() <= 500))
             && (!('skull' in reactions) || (reactions.skull is list && reactions.skull.size() <= 500));
    }

    // Validate message edit by author
    function isValidMessageEdit() {
      let data = request.resource.data;
      let oldData = resource.data;
      let changedFields = data.diff(oldData).affectedKeys();
      
      return changedFields.hasOnly(['text', 'edited'])
             // Cannot change ownership or timestamp
             && data.userId == oldData.userId
             && data.timestamp == oldData.timestamp
             // Validate new text
             && data.text is string
             && data.text.size() > 0
             && data.text.size() <= 2000
             // edited flag must be true
             && data.edited == true;
    }

    // Validate admin message update (for pinning)
    function isValidAdminMessageUpdate() {
      let data = request.resource.data;
      let oldData = resource.data;
      let changedFields = data.diff(oldData).affectedKeys();
      
      return changedFields.hasOnly(['isPinned'])
             && data.isPinned is bool;
    }

    // Validate pinned message (matches app.js togglePinMessage)
    function isValidPinnedMessage() {
      let data = request.resource.data;
      let requiredFields = ['originalId', 'collection', 'text', 'pinnedBy', 'timestamp'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(requiredFields)
             && data.originalId is string
             && data.originalId.size() > 0
             && data.originalId.size() <= 100
             && data.collection in ['chat', 'confessions']
             && data.text is string
             // app.js limits to 200 chars: text?.substring(0, 200)
             && data.text.size() <= 200
             && data.pinnedBy == request.auth.uid
             && data.timestamp == request.time;
    }

    // Validate ban record (matches app.js toggleBanUser)
    function isValidBanRecord() {
      let data = request.resource.data;
      let requiredFields = ['bannedBy', 'timestamp'];
      let optionalFields = ['reason', 'username'];
      let allAllowedFields = ['bannedBy', 'timestamp', 'reason', 'username'];
      
      return data.keys().hasAll(requiredFields)
             && data.keys().hasOnly(allAllowedFields)
             && data.bannedBy == request.auth.uid
             && data.timestamp == request.time
             && (!('reason' in data) || (data.reason is string && data.reason.size() <= 500))
             && (!('username' in data) || (data.username is string && data.username.size() <= 30));
    }

    // ============================
    // 3. USER PROFILES (/users)
    // ============================

    match /users/{userId} {
      // Read: Any authenticated user (for displaying usernames/avatars)
      allow read: if isSignedIn();

      // Create: User creating own profile OR admin banning
      allow create: if (
                      // User creating their own profile
                      isActiveUser()
                      && request.auth.uid == userId
                      && isValidUserProfileCreate()
                    ) || (
                      // Admin creating user doc for banning (user may not have profile yet)
                      isAdmin()
                      && isValidAdminUserCreate()
                    );

      // Update: User editing own profile OR admin banning/unbanning
      allow update: if (
                      // User editing their own profile
                      isActiveUser()
                      && request.auth.uid == userId
                      && isValidUserProfileUpdate()
                    ) || (
                      // Admin updating user's banned status
                      isAdmin()
                      && isValidAdminUserUpdate()
                    );

      // Delete: Admin only
      allow delete: if isAdmin();
    }

    // ============================
    // 4. TYPING STATUS (/typingStatus)
    // ============================

    match /typingStatus/{docId} {
      // Read: Any authenticated user
      allow read: if isSignedIn();

      // Write: Only own typing status
      allow write: if isActiveUser()
                   && request.auth.uid == docId
                   && isValidTypingStatus();
    }

    // ============================
    // 5. BANNED USERS (/banned_users)
    // ============================

    match /banned_users/{userId} {
      // Read: Admin (all) or user checking own ban status
      allow read: if isAdmin() ||
                  (isSignedIn() && request.auth.uid == userId);

      // Create: Admin only with valid structure
      allow create: if isAdmin() && isValidBanRecord();

      // Update: Admin only (for modifying ban reason, etc.)
      allow update: if isAdmin();

      // Delete: Admin only (unban)
      allow delete: if isAdmin();
    }

    // ============================
    // 6. PINNED MESSAGES (/pinned_messages)
    // ============================

    match /pinned_messages/{docId} {
      // Read: Any authenticated user
      allow read: if isSignedIn();

      // Create: Admin only with valid structure
      allow create: if isAdmin() && isValidPinnedMessage();

      // Update: Admin only
      allow update: if isAdmin();

      // Delete: Admin only (unpin)
      allow delete: if isAdmin();
    }

    // ============================
    // 7. ADMIN LIST (/admins) - LOCKED
    // ============================

    match /admins/{docId} {
      // Read: Only existing admins can see admin list
      allow read: if isAdmin();

      // Write: ABSOLUTE BLOCK - Firebase Console/Admin SDK only
      // This prevents ANY client-side exploit from granting admin privileges
      allow write: if false;
    }

    // ============================
    // 8. CHAT & CONFESSIONS (/chat, /confessions)
    // ============================

    match /{collection}/{docId} {
      // Only process chat and confessions collections
      allow read: if isValidCollection(collection) && isSignedIn();

      // CREATE: New message with rate limiting
      allow create: if isValidCollection(collection)
                    && canSendMessage()
                    && isValidMessageCreate();

      // UPDATE: Multiple valid scenarios
      allow update: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      // ADMIN: Pin/Unpin message
                      (
                        isAdmin()
                        && isValidAdminMessageUpdate()
                      )
                      ||
                      // AUTHOR: Edit own message content (within 15 min - enforced client-side)
                      (
                        isActiveUser()
                        && resource.data.userId == request.auth.uid
                        && isValidMessageEdit()
                      )
                      ||
                      // ANY ACTIVE USER: Add/remove reactions
                      (
                        isActiveUser()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['reactions'])
                        && isValidReactionsUpdate()
                      )
                      ||
                      // ANY SIGNED IN USER: Hide message for themselves
                      (
                        isSignedIn()
                        && request.resource.data.diff(resource.data)
                           .affectedKeys()
                           .hasOnly(['hiddenFor'])
                        && isValidHiddenForUpdate()
                      )
                    );

      // DELETE: Author or admin
      allow delete: if isValidCollection(collection)
                    && !isBanned()
                    && (
                      // Author can delete own messages
                      (isActiveUser() && resource.data.userId == request.auth.uid)
                      ||
                      // Admin can delete any message
                      isAdmin()
                    );
    }

    // ============================
    // 9. CATCH-ALL DENY
    // ============================
    // Block ALL undefined collections/documents
    // This prevents attackers from creating arbitrary collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}